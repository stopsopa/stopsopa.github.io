<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />

    <title>Learn - Development & Learning Resources</title>
  </head>
  <body class="layout bg" toc>
    <div class="body">
      <div class="inside">
        <div class="cards toc">
          <h1>Table of Contents</h1>
          <ul data-do-sort>
            <!--             <li><a href="http://">ekstra link</a></li> -->
          </ul>
        </div>
        <h2>Learn</h2>

        <script type="editor" data-lang="sh">

          https://www.solidqueue.co.uk/
          https://dev.37signals.com/solid-cache/
            // from: https://youtu.be/0rlATWBNvMw?t=2322

          Electron:
            https://palette.dev/blog/improving-performance-of-electron-apps
        </script>
        <h2>DDD - Domain Driven Design</h2>

        <script type="editor" data-lang="sh">

          https://youtu.be/4rhzdZIDX_k
          https://martinfowler.com/bliki/DomainDrivenDesign.html
          Book: https://github.com/gmoral/Books/blob/master/Domain%20Driven%20Design%20Tackling%20Complexity%20in%20the%20Heart%20of%20Software%20-%20Eric%20Evans.pdf
            Domain Driven Design - Eric Evans

          DDD is contextual, not dogmatic.
          DDD is not a religion. It is a set of tools.
          DDD is not for every system
          DDD is not about purity          
          DDD must respect technical constraints
          DDD becomes harmful when:
            People worship abstractions
            Ignore performance, tooling, or ops
            Over-model trivial domains

          Later experminet with :
            g(Translate my Symfony/Spring architecture to DDD terms)
            g(Show me a real use case where Evans-style is clearly better)
          
          Core Concepts
            Domain Model: 
              A rich, abstract representation of the business logic, processes, and rules, central to the software design.
            Ubiquitous Language: [ju by quy tys]
              A common, shared vocabulary used by developers and domain experts to ensure everyone speaks the same language, reducing misunderstandings.
                Domain experts <-> Developers
                some members of the team manage to become bilingual, but they become bottlenecks of information flow
            Bounded Context: 
              Bounded Contexts are intentional design boundaries, and they very often align with team boundaries, but not always
                That is usually though true because: Language is social, Models are maintained by people, Ownership matters
              A Bounded Context defines: A model, A language, A set of rules
                Inside it: consistency is mandatory
                Outside it: translation is mandatory
              More general: 
                Teams should keep their own model and vocabulary consistent internally, and not force it on others.
              A clear boundary within which a specific domain model is consistent, preventing confusion across different parts of a large system (e.g., an "Order" context vs. a "Product Catalog" context).
              Large systems are broken into Bounded Contexts, each with its own specialized model, managed by patterns like the Anti-Corruption Layer for integration. 
              sƒÖ obszary w kt√≥rych dokona≈Ça siƒô pewna stabilizacja (powszechne uzgodnienie) s≈Çownictwa i terminologii i dla wszystkich zapoznanych z tym obszarem istnieje ustalony/stabilny jƒôzyk porozumiewania siƒô
              It might be encapsulated in microservice, module, package or team responsibility - what matters is clarity not technology.
              If a word needs explaining - üëâ you probably crossed a context boundary.
              A Bounded Context defines where a specific domain model and its language are valid‚Äîand protects it from other meanings.
              Good example: https://imgur.com/p441qP4 or https://github.com/user-attachments/assets/bab73640-c38d-4099-bb52-535d88b4efc1
            Strategic Design: 
              High-level organization of the domain, identifying core, supporting, and generic subdomains, and mapping relationships between them.
            Tactical Design: 
              Lower-level patterns for building the model within a Bounded Context, including:          

                Rule: 
                  Any business constraint or policy.
                    - Orders must be paid before shipping
                    - Notifications should be sent on cancellation
                    - Retry payment up to 3 times
                Workflow:
                  - Rules about when things happen, not what is allowed
                  - A sequence of steps that coordinate actions over time, possibly across aggregates or systems.
                  - Decides when email is sent
                  - Decides when refund happens
                  - Coordinates multiple steps
                  - NOT: Decides whether cancellation is allowed - that would be Entity's responsibility
          
                Entities: Mutable
                  Objects with a distinct identity (e.g., a specific Customer).
                    TEST: 
                      ‚ÄúThis is the same thing as before, even though it changed‚Äù - then this is entity
                      Created -> changed -> possibly retured - history matter? - probably entity
                  Entities usually: Guard transition, Enforce rules, Encapsulate state changes
                  Entities usually encapsulate rules that govern their own state and consistency
                  Invariants (Always-True Rules) - An invariant is a specific kind of rule - strict, narrower
                  Entities encapsulate rules that protect their own state and invariants; other rules live elsewhere
                
                  
                Value Objects: Immutable
                  Objects defined by their attributes, not identity (e.g., an Address).
                    TEST: 
                      ‚ÄúThis is just a different value now‚Äù - then this is value object
                      No history - just current values
                      $10 today is indistinguishable from $10 tomorrow - No identity - Equality by amount + currency therefore Immutable
          
                  IMPORTANT: Prefer Value objects - promote to Entity when domain demands identity
                Aggregates: 
                  Aggregate borders start and end where from the business perspective the most desirable effect would be to have these operations executed atomically
                  The distinction: 
                    Aggregate is the smallest cluster that must be consistent at all times
                    Transactions should follow aggregates - not define them
                  When transaction spans across multiple calls to surrounding services ‚Äî atomicity becomes impossible and business logic can get stuck in broken states.
                    But that is ok. Just make each aggregate consistent on its own. 
                    In that case coordinate between aggregates asynchronously or via eventual consistency
            
                  Clusters of related entities and value objects treated as a single unit (e.g., an Order with its OrderItems).
                  Eventual consistency:
                    - Changes happen in separate transactions
                    - EC lays Between aggregates
                    - System may be temporarily inconsistent
                    - But guarantees convergence to a valid state
                    - Eventual consistency is not ‚Äúsloppy consistency‚Äù. It is designed, constrained inconsistency.
                    - Opposite is strong consistency (transaction)
                Repositories: 
                  For managing collection-like access to Aggregates.
                  Domain facing abstraction
                Domain Services: 
                  For significant domain logic that doesn't fit naturally within an Entity or Value Object.
                Domain Events: 
                  Notifications about something important that happened in the domain (e.g., "OrderPlaced"). 
                Anticorruption layer:
                  
              Business Invariance - remains always true, no matter what 
                (eg: product order total have to be sum of all product ordered)

          Benefits
            Better Alignment: Software stays tightly coupled with changing business needs.
            Improved Communication: A shared language reduces ambiguity.
            Maintainability: Complex logic is organized logically and predictably.
            Scalability: Helps manage complexity in large, evolving systems. 
          
          Hexagonal Architecture:  https://youtu.be/bDWApqAUjEI
          
          
        </script>
      </div>
    </div>
    <script type="module" src="/js/github.js"></script>
  </body>
</html>
