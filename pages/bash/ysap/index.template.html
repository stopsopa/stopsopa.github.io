<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />

    <title>stopsopa.github.io</title>
  </head>
  <body class="layout bg" toc>
    <div class="body">
      <div class="inside">
        <div class="cards toc">
          <h1>Table of Contents</h1>
          <ul data-do-sort>
            <li><a href="http://">ekstra link</a></li>
          </ul>
        </div>

        <h2>Course</h2>
        <script type="editor" data-lang="sh">

          # REPL - Read Evaluate Print Loop https://youtu.be/Sx9zG7wa4FA?t=414

          cat /usr/share/dict/words
              # interesting https://youtu.be/Sx9zG7wa4FA

          # loop https://youtu.be/Sx9zG7wa4FA?t=4414
            for thing in foo bar baz bat; do
              echo "thing is $thing"
            done

            for thing in "$@"; do
              echo "thing is $thing"
            done
              # from: https://youtu.be/Sx9zG7wa4FA?t=4956

          # syntax checker - that will check if file syntax is correct
              bash -n ttt.sh
              # use also shellcheck [our script] - but it have to be installed

          for thing in {1..5}; do
            echo "thing is $thing"
          done
              # from: https://youtu.be/Sx9zG7wa4FA?t=6026

          for ((i=1; i<=5; i++)); do
            echo "thing is $i"
          done
              # from: https://youtu.be/Sx9zG7wa4FA?t=6084

          while read -r line; do
            echo "line is $line"
          done
              # cat /usr/share/dict/words | /bin/bash ttt.sh
              # from: https://youtu.be/Sx9zG7wa4FA?t=6412

          # hexdump
              echo hello | hexdump
              echo hello | hexdump -C
              echo -n hello | hexdump -C   # '0a' is new line
              echo hello | od
              echo hello | xxd
                  # from: https://youtu.be/Sx9zG7wa4FA?t=6478
          while read -r line || [[ -n $line ]]; do
            echo "line is $line"
          done
              # [[ -n $line ]] - makes it more bullet proof because it will accept line from
                # echo -n test | /bin/bash ttt.sh
              # cat /usr/share/dict/words | /bin/bash ttt.sh\
              # from: https://youtu.be/Sx9zG7wa4FA?t=6573

          /bin/bash ttt.sh < /usr/share/dict/words
          < /usr/share/dict/words /bin/bash ttt.sh
              # Useless CAT - avoided

          # case
              s=$1
              case "$s" in
              dave)
                  echo "hi dave"
                  ;;
              buddy* | test*)
                  # anything starting with 'buddy' or 'test'
                  echo "ohhh there he is"
                  ;;
              guy)
                  echo "hi guy"
                  ;;
              *)
                  echo who are you $s "?"
                  ;;
              esac

              # or

              s=$1
              case "$s" in
                  dave)echo "hi dave";;
                  buddy)echo "ohhh there he is";;
                  guy)echo "hi guy";;
                  *)echo who are you $s "?";;
              esac

              # /bin/bash ttt.sh fdafs
              $ from: https://youtu.be/Sx9zG7wa4FA?t=7251


              # always fallthrough
              # WARNING: case with ;;& won't work with bash 3.2 from mac (check /bin/bash --version)
              # let's use ubuntu via docker
              urlwizzard.schema://urlwizzard.hostnegotiated/pages/bash/index.html#bash-versions



                  s=$1
                  case "$s" in
                      d*)echo "dave star";;&
                      dave)echo "hi dave";;&
                      buddy)echo "ohhh there he is";;&
                      guy)echo "hi guy";;&
                      *)echo who are you $s "?";;&
                  esac

                  # from: https://youtu.be/Sx9zG7wa4FA?t=7492

          # array: https://youtu.be/Sx9zG7wa4FA?t=7842

              # array=( # this syntax will do too
              declare -a array=(
                  "dave"
                  "buddy"
                  "guy"
                  "hey there friend"
              )

              echo ${array[@]}

              echo ----
              echo ${array[0]}
              echo ${array[1]}
              echo ${array[2]}

              echo ---idx
              idx=1
              echo ${array[idx]}

              echo ---loop
              # for i in ${array[@]}; do # this one is incorrect - will process each word separately
              # for i in "${array[*]}"; do # this one means cast array to string, so one iteration for the whole array
              # WARNING:
              # ${arr[*]} → joins elements using first character of IFS
              # ${arr[@]} → preserves elements as separate words
              for i in "${array[@]}"; do # only that will process correctly
                  echo $i
              done

              echo ---copied

              array2=(on start "${array[@]}" some [45]=more)
              array2+=(and more) # push to array
              for i in "${array2[@]}"; do
                  echo $i
              done

              echo ---inspect array
              declare -p array2
              # will print https://youtu.be/Sx9zG7wa4FA?t=8278
              # declare -a array2='([0]="on" [1]="start" [2]="dave" [3]="buddy" [4]="guy" [5]="hey there friend" [6]="some" [45]="more" [46]="and" [47]="more")'

              echo ---length of array
              echo "${#array2[@]}"
              echo ">$(echo ${#array2[@]})<"
              echo ">$((${#array2[47]}))<"  # get length of specific element

          # associative-arrays https://youtu.be/Sx9zG7wa4FA?t=8370

          # /bin/bash pages/bash/ysap/associative_array.sh
             <%inject associative_array.sh %>

          # arithmetic expression https://youtu.be/Sx9zG7wa4FA?t=9866

          # /bin/bash pages/bash/ysap/arithmetic_expression.sh
             <%inject arithmetic_expression.sh %>

          set and positional parameters
          IFS=,
          set -- a,b,c
          echo ">$1<" ">$2<" ">$3<"

          IFS=,
          read a b c <<< "one,two,three"
          echo ">$a<" ">$b<" ">$c<"

            Once consequence of using IFS - some gotchas
            touch "first file.txt" "second file.txt"
            for file in $(ls *.txt); do
              echo ">$file<"
            done
              # this is incorrect

            for file in *.txt; do
              echo ">$file<"
            done
              # this is fine

            ls *.txt | while IFS= read -r file; do
              echo ">${file}<"
            done
              # this is fine

            readarray -t files < <(ls *.txt)
            for file in "${files[@]}"; do
              echo ">${file}<"
            done
              # this is fine
              # WARNING: THIS ONLY WORKS IN BASH 4.0+ not in ZSH

          # csv processing https://youtu.be/Sx9zG7wa4FA?t=11684

          # /bin/bash pages/bash/ysap/csv_parser.sh
             <%inject csv_parser.sh %>

          # man 5 passwd
          cat /etc/passwd | cut -d : -f 1
          cut -d : -f 1 /etc/passwd

          # https://youtu.be/Sx9zG7wa4FA?t=13543
          PS4="[debug]: " /bin/bash pages/bash/ysap/csv_parser.sh

          # /bin/bash pages/bash/ysap/undefined.sh
          # /bin/bash -u pages/bash/ysap/undefined.sh
          # /bin/bash -n pages/bash/ysap/undefined.sh
          # /bin/bash -u -n pages/bash/ysap/undefined.sh
          # NOTE: -u doesn't work with -n -> which means -u is detecting during runtime, not statically
             <%inject undefined.sh %>

          # source https://youtu.be/Sx9zG7wa4FA?t=14732

          # /bin/bash pages/bash/ysap/greetings_main.sh
            <%inject greetings_main.sh %>

          # ARRAY EXPANSION: https://youtu.be/Sx9zG7wa4FA?t=16906
          # /bin/bash pages/bash/ysap/array_expansion.sh
            <%inject array_expansion.sh %>

          # GLOBS https://youtu.be/Sx9zG7wa4FA?t=17159
          # /bin/bash pages/bash/ysap/globs.sh
            <%inject globs.sh %>

            # shopt  https://youtu.be/Sx9zG7wa4FA?t=17369
              # options
            shopt
              # to list all options and if enabled or not
            shaopt extglob
              # test just one option
            shopt -s extglob
              # enable option (SET)
            shopt -u extglob
              # disable option (UNSET)

            # apparently it is good idea to turn on set -H https://youtu.be/Sx9zG7wa4FA?t=17377

          # BRACE EXPANSION
            echo file{1,5}.txt
              # file1.txt file5.txt
            echo file{1..5}.txt
              # file1.txt file2.txt file3.txt file4.txt file5.txt
            echo file{0..6..2}.{json,txt}
              # file0.json file0.txt file2.json file2.txt file4.json file4.txt file6.json file6.txt

            echo file{a,b{1,2},c}.{json,txt}
              # filea.json filea.txt fileb1.json fileb1.txt fileb2.json fileb2.txt filec.json filec.txt

            mv report{,_old}.txt
              # mv report.txt report_old.txt

            for i in {1..3}; do echo "Run $i"; done
              # Run 1
              # Run 2
              # Run 3

            # spaces breaks expansion
            echo {a, b, c}
              # {a, b, c}

            x=5
            echo {1..$x}
              # THAT WON'T WORK, IT WILL PRINT {1..5}

            eval echo {1..$x}
              # 1 2 3 4 5

            # quoting also disables expansion
            echo "{a,b,c}"
              # {a,b,c}

            YEAR=$(date +%Y)

            for i in {1995..$YEAR}; do
              echo ">${i}<"
            done

            for (( i=1995; i<=YEAR; i++ )); do
              echo ">${i}<"
            done

          # PRINTF https://youtu.be/Sx9zG7wa4FA?t=18884

            printf '%s\n' {1..3}
            s="Hello world"
            printf 'message >%s<\n' "$s"

            # padding on the left
            printf "[%10s][%10s]\n" hi there
              # prints >[     hi][     there] <

            # padding on the right
            printf "[%-10s][%-10s]\n" hi there
              # prints >[hi        ][there     ]<

            # control how much to pad (ON THE LEFT)
            printf "[%*s]\n" 10 hi
            printf "[%*s]\n" 30 hi

            # control how much to pad (ON THE RIGHT)
            printf "[%-*s]\n" 10 hi
            printf "[%-*s]\n" 30 hi

            # number
            printf '[%d]\n' 123
              # print >[123]<
            printf '[%5d]\n' 123
              # print >[  123]<
            printf '[%-5d]\n' 123
              # print >[123  ]<
            printf '[%05d]\n' 123
              # print >[00123]<
            printf '[%08d]\n' 123456
              # print >[00123456]<
            printf '[%-08d]\n' 123456 # <-that won't work and there is not verison nor %0-8d - that is not valid too

          # DATE FORMATTING https://youtu.be/Sx9zG7wa4FA?t=19506
            datefmt="%Y-%M-%d %H:%M:%S"
            date +"$datefmt"  # the thing is that this might not always work - depending on the shell
              # I haven't been able to make it fail with versions from 
              # urlwizzard.schema://urlwizzard.hostnegotiated/pages/bash/index.html?admin:password#bash-versions
              # prints >2025-35-29 15:35:28<
            # apparently better way is to use printf
            printf '%(%Y/%m/%d %H:%M:%S)T\n' 
              # aaaand actually this is bullshit, because printf with dates actually fails in some shells 
              # where date +fmt didn't faile anywhere
        </script>

        <h2>PIPESTATUS</h2>
        <script type="editor" data-lang="sh">
          # ${PIPESTATUS}  https://youtu.be/Sx9zG7wa4FA?t=14038

          # /bin/bash pages/bash/ysap/pipestatus.sh
          <%inject pipestatus.sh %>
        </script>

        <h2>Parameter Expansion</h2>
        <script type="editor" data-lang="sh">
          # https://youtu.be/Sx9zG7wa4FA?t=16123

          # /bin/bash pages/bash/ysap/parameter_expansion.sh
          <%inject parameter_expansion.sh %>
        </script>
      </div>
    </div>
    <script type="module" src="/js/github.js"></script>
  </body>
</html>
