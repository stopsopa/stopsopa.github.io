<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />

    <title>stopsopa.github.io</title>
  </head>
  <body class="layout bg" toc>
    <div class="body">
      <div class="inside">
        <div class="cards toc">
          <h1>Table of Contents</h1>
          <ul data-do-sort>
            <li><a href="http://">ekstra link</a></li>
          </ul>
        </div>

        <h2>Course</h2>
        <script type="editor" data-lang="sh">

          # REPL - Read Evaluate Print Loop https://youtu.be/Sx9zG7wa4FA?t=414

          cat /usr/share/dict/words
              # interesting https://youtu.be/Sx9zG7wa4FA

          # loop https://youtu.be/Sx9zG7wa4FA?t=4414
            for thing in foo bar baz bat; do
              echo "thing is $thing"
            done

            for thing in "$@"; do
              echo "thing is $thing"
            done
              # from: https://youtu.be/Sx9zG7wa4FA?t=4956

          # syntax checker - that will check if file syntax is correct
              bash -n ttt.sh
              # use also shellcheck [our script] - but it have to be installed

          for thing in {1..5}; do
            echo "thing is $thing"
          done
              # from: https://youtu.be/Sx9zG7wa4FA?t=6026

          for ((i=1; i<=5; i++)); do
            echo "thing is $i"
          done
              # from: https://youtu.be/Sx9zG7wa4FA?t=6084

          while read -r line; do
            echo "line is $line"
          done
              # cat /usr/share/dict/words | /bin/bash ttt.sh
              # from: https://youtu.be/Sx9zG7wa4FA?t=6412

          # hexdump
              echo hello | hexdump
              echo hello | hexdump -C
              echo -n hello | hexdump -C   # '0a' is new line
              echo hello | od
              echo hello | xxd
                  # from: https://youtu.be/Sx9zG7wa4FA?t=6478
          while read -r line || [[ -n $line ]]; do
            echo "line is $line"
          done
              # [[ -n $line ]] - makes it more bullet proof because it will accept line from
                # echo -n test | /bin/bash ttt.sh
              # cat /usr/share/dict/words | /bin/bash ttt.sh\
              # from: https://youtu.be/Sx9zG7wa4FA?t=6573

          /bin/bash ttt.sh < /usr/share/dict/words
          < /usr/share/dict/words /bin/bash ttt.sh
              # Useless CAT - avoided

          # case
              s=$1
              case "$s" in
              dave)
                  echo "hi dave"
                  ;;
              buddy* | test*)
                  # anything starting with 'buddy' or 'test'
                  echo "ohhh there he is"
                  ;;
              guy)
                  echo "hi guy"
                  ;;
              *)
                  echo who are you $s "?"
                  ;;
              esac

              # or

              s=$1
              case "$s" in
                  dave)echo "hi dave";;
                  buddy)echo "ohhh there he is";;
                  guy)echo "hi guy";;
                  *)echo who are you $s "?";;
              esac

              # /bin/bash ttt.sh fdafs
              $ from: https://youtu.be/Sx9zG7wa4FA?t=7251


              # always fallthrough
              # WARNING: case with ;;& won't work with bash 3.2 from mac (check /bin/bash --version)
              # let's use ubuntu via docker
              urlwizzard.schema://urlwizzard.hostnegotiated/pages/bash/index.html#bash-versions



                  s=$1
                  case "$s" in
                      d*)echo "dave star";;&
                      dave)echo "hi dave";;&
                      buddy)echo "ohhh there he is";;&
                      guy)echo "hi guy";;&
                      *)echo who are you $s "?";;&
                  esac

                  # from: https://youtu.be/Sx9zG7wa4FA?t=7492

          # array: https://youtu.be/Sx9zG7wa4FA?t=7842

              # array=( # this syntax will do too
              declare -a array=(
                  "dave"
                  "buddy"
                  "guy"
                  "hey there friend"
              )

              echo ${array[@]}

              echo ----
              echo ${array[0]}
              echo ${array[1]}
              echo ${array[2]}

              echo ---idx
              idx=1
              echo ${array[idx]}

              echo ---loop
              # for i in ${array[@]}; do # this one is incorrect - will process each word separately
              # for i in "${array[*]}"; do # this one means cast array to string, so one iteration for the whole array
              # WARNING:
              # ${arr[*]} → joins elements using first character of IFS
              # ${arr[@]} → preserves elements as separate words
              for i in "${array[@]}"; do # only that will process correctly
                  echo $i
              done

              echo ---copied

              array2=(on start "${array[@]}" some [45]=more)
              array2+=(and more) # push to array
              for i in "${array2[@]}"; do
                  echo $i
              done

              echo ---inspect array
              declare -p array2
              # will print https://youtu.be/Sx9zG7wa4FA?t=8278
              # declare -a array2='([0]="on" [1]="start" [2]="dave" [3]="buddy" [4]="guy" [5]="hey there friend" [6]="some" [45]="more" [46]="and" [47]="more")'

              echo ---length of array
              echo "${#array2[@]}"
              echo ">$(echo ${#array2[@]})<"
              echo ">$((${#array2[47]}))<"  # get length of specific element

          # associative-arrays https://youtu.be/Sx9zG7wa4FA?t=8370

          # /bin/bash pages/bash/ysap/associative_array.sh
             <%inject associative_array.sh %>

          # arithmetic expression https://youtu.be/Sx9zG7wa4FA?t=9866

          # /bin/bash pages/bash/ysap/arithmetic_expression.sh
             <%inject arithmetic_expression.sh %>

          set and positional parameters
          IFS=,
          set -- a,b,c
          echo ">$1<" ">$2<" ">$3<"

          IFS=,
          read a b c <<< "one,two,three"
          echo ">$a<" ">$b<" ">$c<"

            Once consequence of using IFS - some gotchas
            touch "first file.txt" "second file.txt"
            for file in $(ls *.txt); do
              echo ">$file<"
            done
              # this is incorrect

            for file in *.txt; do
              echo ">$file<"
            done
              # this is fine

            ls *.txt | while IFS= read -r file; do
              echo ">${file}<"
            done
              # this is fine

            readarray -t files < <(ls *.txt)
            for file in "${files[@]}"; do
              echo ">${file}<"
            done
              # this is fine
              # WARNING: THIS ONLY WORKS IN BASH 4.0+ not in ZSH

          # csv processing https://youtu.be/Sx9zG7wa4FA?t=11684

          # /bin/bash pages/bash/ysap/csv_parser.sh
             <%inject csv_parser.sh %>

          # man 5 passwd
          cat /etc/passwd | cut -d : -f 1
          cut -d : -f 1 /etc/passwd

          # https://youtu.be/Sx9zG7wa4FA?t=13543
          PS4="[debug]: " /bin/bash pages/bash/ysap/csv_parser.sh

          # /bin/bash pages/bash/ysap/undefined.sh
          # /bin/bash -u pages/bash/ysap/undefined.sh
          # /bin/bash -n pages/bash/ysap/undefined.sh
          # /bin/bash -u -n pages/bash/ysap/undefined.sh
          # NOTE: -u doesn't work with -n -> which means -u is detecting during runtime, not statically
             <%inject undefined.sh %>
        </script>

        <h2>PIPESTATUS</h2>
        <script type="editor" data-lang="sh">
          # ${PIPESTATUS}  https://youtu.be/Sx9zG7wa4FA?t=14038

          # /bin/bash pages/bash/ysap/pipestatus.sh
          <%inject pipestatus.sh %>
        </script>
      </div>
    </div>
    <script type="module" src="/js/github.js"></script>
  </body>
</html>
