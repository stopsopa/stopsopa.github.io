<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>stopsopa.github.io</title>

    <style>
      pre {
        white-space: pre-wrap;
      }
    </style>

    <script src="/public/preprocessed.js"></script>
    <script>
      (function () {
        var resolve;
        var p = new Promise(function (res) {
          resolve = res;
        });

        // <a href="GITHUB_SOURCES_PREFIX/blob/master/pages/bash/rsync.sh">rsync.sh</a>
        document.addEventListener("DOMContentLoaded", () => {
          const GITHUB_SOURCES_PREFIX = env("GITHUB_SOURCES_PREFIX");

          if (typeof GITHUB_SOURCES_PREFIX !== "string" || !GITHUB_SOURCES_PREFIX.trim()) {
            throw new Error(`GITHUB_SOURCES_PREFIX is not defined`);
          }

          const reg = /^GITHUB_SOURCES_PREFIX(.*)/;

          const buff = {
            reg,
            a_match: [],
            a_notmatch: [],
          };

          document.querySelectorAll("a").forEach((a) => {
            const href = a.getAttribute("href");

            if (reg.test(href)) {
              buff.a_match.push(href);

              const newhref = href.replace(/^GITHUB_SOURCES_PREFIX(.*)/, `${GITHUB_SOURCES_PREFIX}$1`);

              a.setAttribute("href", newhref);
            } else {
              buff.a_notmatch.push(href);
            }
          });

          console.log(JSON.stringify(buff, null, 4));

          resolve();
        });

        window.beforeAceEventPromise = function () {
          return p;
        };
      })();
    </script>
  </head>
  <body class="layout" toc>
    <div class="body">
      <div class="inside">
        <div class="cards toc">
          <h1>Table of Contents</h1>
          <ul>
            <li><a href="./sed.html">sed</a></li>
            <li><a href="./awk.html">awk</a></li>
          </ul>
          <h2>useful</h2>
          <script type="editor" data-lang="sh">

            # expand HOME directory
            TARGET="~/.m2"
            eval TARGET="${TARGET}"
            # or simply
            eval TARGET="~/.m2";
            echo ">${TARGET}<"


            # fix variables in ide
            WEBSTORM:
            (?<!\\)(?<!\{\s*print\s)\$([a-zA-Z_\d+]+|[\d+\*#\?@$\!-])
            \${$1}

            VSCODE:
            $([A-Za-z_\d!]+)
            ${$1}



            # ------- find and iterate ------- vvv


            # handleExitCode ${?} "oc project"
            function handleExitCode {
              if [ "${1}" != "0"  ]; then
                  echo "handleExitCode: exit code not 0 >${1}< for ${2}"
                  exit 1
              fi
            }



            trim() {
                local var="${*}"
                # remove leading whitespace characters
                var="${var#"${var%%[![:space:]]*}"}"
                # remove trailing whitespace characters
                var="${var%"${var##*[![:space:]]}"}"
                echo -n "${var}"
            }
            trimstring(){ # from: https://jcgoran.github.io/2021/02/07/bash-string-trimming.html
                if [ $# -ne 1 ]
                then
                    echo "USAGE: trimstring [STRING]"
                    return 1
                fi
                s="${1}"
                size_before=${#s}
                size_after=0
                while [ ${size_before} -ne ${size_after} ]
                do
                    size_before=${#s}
                    s="${s#[[:space:]]}"
                    s="${s%[[:space:]]}"
                    size_after=${#s}
                done
                echo "${s}"
                return 0
            }
            LIST="$(find . -type d -name 'node_modules' -prune -o -type f -name .yarnrc -print)"

            LIST="$(trim "${LIST}")"

            _P="$(pwd)"
            if [ "${LIST}" = "" ]; then

              cat <<EEE

              nothing found

            EEE
            else
              COUNT="$(echo "${LIST}" | wc -l)"
              COUNT="$(trim "${COUNT}")"
              I="0"
              while read -r xxx
              do

                cd "$_P"

                I="$(($I + 1))"

                echo -e "\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ${I} : ${COUNT}"
                DIR="$(dirname "${xxx}")"

                cd "${DIR}"
                echo "${xxx}" >> "${_P}/log.log"
                cat "${_P}/${xxx}" >> "${_P}/log.log"
                echo -e "\n\n" >> "${_P}/log.log"

              done <<< "${LIST}"
            fi

            cd "$_P"







            # ------- find and iterate ------- ^^^

            export PATH="${PATH}:/new/path"

            # manpages
            cat <<EOF | docker build -t ubuntu:18.04-man -
            FROM ubuntu:18.04
            RUN apt-get update && yes | unminimize
            EOF
            docker images | grep ubuntu | grep 18.04-man
            docker run -it ubuntu:18.04-man bash


            # path interpolation

            mkdir -p ~/__test/one\ two/three/four
            _SS="~/__test/one two/three/four"
            _SS="$(echo "${_SS}" | sed -E 's/( )/\\\1/g')"
            eval _SS="${_SS}"
            echo ">${_SS}<"


            # if some linux tool is missing on mac, use linux
            docker run -t -v "$(pwd):/opt/code" -w "/opt/code" ubuntu find -type f -executable

            export _KILL="arang"; ps aux | grep "${_KILL}" | grep -v grep;echo "\n    are you sure? (y) \"${_KILL}\"\n"; read VAL; if [ "${VAL}" = "y" ]; then kill $(ps aux | grep "${_KILL}" | grep -v grep | awk '{print $2}'); else echo canceled...; fi

            source ".env"
            export $(cut -d= -f1 ".env" | grep -v -E "^#" | tr "\n" " ")
                # from: https://github.com/stopsopa/stopsopa.github.io/blob/master/bash/exportsource.sh



            # find .git/config with given git source path
            find . -type f -name config | grep --color=never -v node_modules | grep --color=never /.git/config | xargs -n 1 realpath | xargs -n 1 -- bash -c '
            FILE="$0" # because it is inline script (bash -c) then first arg is not a 1 arg but 0
            STDOUT="$(awk "{
                if (\$0 ~ /git@bitbucket\.org:org\/proj\.git/) {
                    print \$0
                }
            }" "$FILE")"

            if [ "$STDOUT" = "" ]; then
                echo "$FILE not found"
            else
                echo -e "$FILE \033[32mFOUND\e[0m"
            fi
            '

            # pick choose by number from the list
            SSHS="$(echo "${_LIST}" | sed -n "${i} p")"

            # basename and file extension
            PD="$(dirname "${FILE}")"
            PB="$(basename "${FILE}")"
            EXTENSION="${PB##*.}"
            FILENAME="${PB%.*}"
            if [ "${FILENAME}" = "" ]; then
                FILENAME="${PB}"
                EXTENSION=""
            fi
            if [ "${FILENAME}" = "${PB}" ]; then
                EXTENSION=""
            fi

            # exists in file, file contains
            if [ "$(cat ~/.zshrc | grep 'tartufo')" = "" ]; then
                # yep - it exists
            fi


            # reading one character in zsh, bash
            { red "${COUNT} files found (more than ${MAX}), are you sure you want to include them to other libraries them? (y|n)\n"; } 2>&3
            if [ "${_BINARY}" = "/bin/zsh" ]; then
              read -sk
            else
              read -n 1
            fi
            echo "REPLY=$REPLY"
            echo    # (optional) move to a new line
            if ! [[ $REPLY =~ ^[Yy]$ ]]; then
              { green "script stopped"; } 2>&3
              exit 1
            fi


            # pipe stin to function:
            cat <<FILE > ___test.sh
            function _osht_xmlencode {
                sed -e 's/\&/\&amp;/g' -e 's/\"/\&quot;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'
                # To be painfully explicit  https://stackoverflow.com/a/14009482
                # cat - | sed -e 's/\&/\&amp;/g' -e 's/\"/\&quot;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'
            }
            function grephello {
                grep HELLO
            }
            cat <<EOF | _osht_xmlencode
            VVVVV
            first & and && ;
            second " mid > mid
            almost < near > end
            ^^^^^^
            EOF
            cat <<EOF | grephello
            VVVVV
            normal
            xxx HELLO test
            mid
            HELLO
            end
            ^^^^^^
            EOF
            FILE
            /bin/bash ___test.sh
            rm -rf ___test.sh


            # cut from beginning
            echo test | md5 | cut -c 1-5

            /bin/bash -c "while true
            do
                date "+%Y_%m_%d_%H_%M_%S"
                echo test
                sleep 30
            done
            " 2>&1 | tee log.log


            function extractValueFromJsonByKey {
              local INPUT="$(cat)"

              REG="^.*\"${1}\"[[:space:]]*:[[:space:]]*\"([^\"]+)\".*\$"

              if [[ ${INPUT} =~ ${REG} ]]; then

                  echo "${INPUT}" | tr '\n' '\f' | sed -E "s/${REG}/\1/"
              fi
            }

            function validateSecret {

              REG="^[a-zA-Z0-9\+\/]+\$"

              if ! [[ ${2} =~ ${REG} ]]; then

                  echo "validateSecret value '${2}' from key '${1}' don't match ${REG}"

                  exit 1;
              fi
            }

            # idea from: https://unix.stackexchange.com/a/522054
            # usage
            #  divideInTwo "abcde" " ---- "
            function divideInTwo {

              DELIMITER="${2}"

              if [ "${DELIMITER}" = "" ]; then
                DELIMITER="<-**->"
              fi

              printf "${1:0:${#1}/2}${DELIMITER}${1:${#1}/2}"
            }
            echo "AWS_ACCESS_KEY_ID >$(divideInTwo "${AWS_ACCESS_KEY_ID}")<"
          </script>

          <h2>Get exit status of process that's piped to another</h2>
          <a href="https://unix.stackexchange.com/a/14276">https://unix.stackexchange.com/a/14276</a>
          <h2>Books and manuals</h2>
          <a href="https://doc.lagout.org/operating%20system%20/linux/Classic%20Shell%20Scripting.pdf">Classic Shell Scripting</a>
          <br />
          <a href="https://www.google.com/search?q=advanced+bash+scripting+guide+pdf">g(advanced bash scripting guide pdf)</a>
          <br />
          <a href="https://kapeli.com/cheat_sheets/Bash_Test_Operators.docset/Contents/Resources/Documents/index">g(Bash Test Operators)</a>
          <h2>jq</h2>
          <a href="https://stedolan.github.io/jq/">https://stedolan.github.io/jq/</a>
          <script type="editor" data-lang="sh">

            jqs() {
              FILE="${1}" && echo "$(cat "${FILE}" | jq --sort-keys)" > "${FILE}"
            }

            jqs="jqs"


            # examples
            cat <<EEE | jq ".abc"
            {
              "abc": "def"
            }
            EEE
            # prints >"def"<

            cat <<EEE | jq -r ".abc"
            {
              "abc": "def"
            }
            EEE
            # prints >def<

            cat <<EEE | jq "keys"
            {
              "abc": "def",
              "cef": "ghi"
            }
            EEE
            # prints >[
            #  "abc",
            #  "cef"
            #]<
          </script>
          <a href="https://stedolan.github.io/jq/manual/">https://stedolan.github.io/jq/manual/</a>
          <br />
          <a href="https://ss64.com/bash/syntax.html">https://ss64.com/bash/syntax.html</a>
        </div>

        <h2>Hash table</h2>
        <a href="https://stackoverflow.com/questions/1494178/how-to-define-hash-tables-in-bash">https://stackoverflow.com/questions/1494178/how-to-define-hash-tables-in-bash</a>
        <br />
        <a href="https://levelup.gitconnected.com/5-less-known-bash-concepts-to-level-up-your-linux-skills-7bcf363804d1"
          >https://levelup.gitconnected.com/5-less-known-bash-concepts-to-level-up-your-linux-skills-7bcf363804d1</a
        >
        <h2>inode</h2>
        <script type="editor" data-lang="sh">

          touch -
          # create file named '-'

          ls -i
          # list files with its inode name

          find . -inum xxxxx -exec rm {} \;
          # remove file by inode

            # from: https://developer.ibm.com/articles/au-speakingunix14/#the-ls-command
        </script>
        <h2>glob</h2>
        <script type="editor" data-lang="sh">

          # testing glob pattern - what files it will find
          ls -la **/*.spec.js

          echo -n **/*.spec.js | tr " " "\n" | grep -v -i -E '^node_modules\/'
          echo -n tests/**/*.spec.js | tr " " "\n" | grep -v -i -E '^node_modules\/'
        </script>
        <h2>rsync</h2>
        <a href="GITHUB_SOURCES_PREFIX/blob/master/pages/bash/rsync.sh">rsync.sh</a>
        <script type="editor" data-lang="sh">

          # WARNING: remember if you are copying directories always specify / at the end of paths:

          # examples:
            rsync -azP root@xxx.xx.xx.xxx:/var/www/ /var/www/
            rsync -rtlDzPvi root@xxx.xx.xx.xxx:/var/www/ /var/www/
            # this will copy new files to the target
            # it is safe to run again and again
            # it will not remove files in the target if they were removed in the source
            # -l   - copy links
            # -z, --compress
            # -t, --times                 preserve times
            #                             WARNING: this one is actually very important to add because if not then later
            #                             in next execution while file comparison will be performed on each file
            #                             comparision is heavly based on timestamp. Withouth preserving timestamp
            #                             while copying you will end up with lots of false positive
            # -P     The -P option is equivalent to --partial --progress
            # -a, --archive
            #           This is equivalent to -rlptgoD.
            #           It is a quick way of saying you want recursion and want to
            #           preserve almost everything (with -H being a notable omission)
            # in -rtlDzP I've dropped -ptgo, p-perms, t-times, g-group, o-owner

          # ! might be destructive:
          # rsync -azP --delete-after root@xxx.xx.xx.xxx:/var/www/ /var/www/ -n
              # -n -> --dry-run
              # --delete-after   -> This tells rsync to delete extraneous files from the receiving side
              # if ok then remove then buckle up, remove -n and execute it

          # TIPS/USEFUL:
              # --ignore-existing         this will skip updating files on target (even if it have different content).
              #                           will just check if it exists and if it does it will be skipped
              # -i, --itemize-changes     to understand why file is considered "different"
              # --ignore-times            will make sure to really compare content of files
              #                           more on this one: https://stackoverflow.com/a/13779300
              # -c, --checksum            skip based on checksum, not mod-time & size
              #                           very thorough approach if you really care about content match
              #                           but might be very slow because it reads all data (from source and target) to generate checksum
              # -v, --verbose             increase verbosity

          # other examples:

            rsync -avzp --rsh='ssh -p23022' /srv/www site@xxx.xx.xx.xxx:/home/www/

          # ISSUES:
            ON MAC USE BUILDIN VERSION BECAUSE YOU WILL AVOID ISSUE WITH RSYNC COPYING THE SAME LIST OF FILES EVERY TIME YOU TRIGGER RSYNC:
            https://superuser.com/a/1730435
        </script>
        <a href="https://www.andrew.cmu.edu/course/15-749/READINGS/required/cas/tridgell96.pdf">g(TR-CS-96-05 The rsync algorithm Andrew Tridgell and Paul Mackerras June 1996)</a>

        <h2>prepend date to each stream line</h2>

        <script type="editor" data-lang="sh">

          node -e "
          const {EOL} = require('os');
          let k = 5;
          (function loop() {
            if (k !== 0) {
              setTimeout(loop, 1000);
            }
            process.stdout.write('stdout: ' + k + EOL);
            process.stderr.write('stderr: ' + k + EOL);
            k -= 1;
          }());
          " |& while IFS= read -r line; do printf '[%s] %s\n' "$(date '+%Y-%m-%d %H:%M:%S') process" "$line"; done

                # from: https://unix.stackexchange.com/a/26729
        </script>
        <div class="cards">
          <h2>grep</h2>
          <script type="editor" data-lang="sh">

            # grep by regex
            # -i case insensitive - by default grep is case sensitive
            cat <<EEE | grep -i -E '^[a-f0-9]+$'
            ff fff
            fdsa fdjsafds899
            08850cb8ceb58b51f23fa63148a0ce0306e8697a
            d 67jk

            EEE

            # grep filter replace
            echo "  AccessKeyId: sfreteree" | sed -E 's/^[[:space:]]+AccessKeyId:[[:space:]]+(.*)\$/\1/g'
            #cat <<EEE | grep -i -E '^settings_[a-z_\-]+\.xml$' | sed -E 's/^settings_([a-z_-]+).xml$/\1/g'
            cat <<EEE | grep -i -E '^settings_[a-z_\-]+\.xml$' | perl -pe 's#^settings_([a-z_-]+).xml$#\1#g'
            settings_abc_def-ghi.xml
            settings_abc.xml
            settings_abc.xml2
            dsettings_abc.xml

            end
            settings_endz.xml
            EEE
          </script>
          <h2>cli keystrokes</h2>
          <script type="editor" data-lang="sh">

            ctrl + k - cut everything on the right from cursor
            ctrl + u - cut everything on the right from cursor
            ctrl + y - paste back what was previously cut with ctrl + k or u
            ctrl + w - cut one "word" back
            ctrl + x + e - open buffer in editor, then :wq (if this is vim) to execute;

            reset -
          </script>
          <h2>function arguments - processing inside</h2>
          <script type="editor" data-lang="sh">

            cat <<EEE > ___test.sh
            function proc {

              echo "--->${0}<"

              echo "proc >${@}<"

              shift

              echo "proc >${@}<"
            }

            echo "global >${@}<"

            proc ${@}

            proc f g h

            TEST="proc $@";

            ${TEST}

            echo "global >${@}<"
            EEE

            /bin/bash ___test.sh
            # will print
            # global >a b c<
            # --->ttt.sh<
            # proc >a b c<
            # proc >b c<
            # --->ttt.sh<
            # proc >f g h<
            # proc >g h<
            # --->ttt.sh<
            # proc >a b c<
            # proc >b c<
            # global >a b c<
          </script>
          <h2>stream buffer control</h2>
          <a href="https://stackoverflow.com/questions/71782041/sed-and-tee-when-working-together-no-longer-behaves-like-stream">Stackoverflow question I've asked</a>
          <br />
          <a href="http://www.pixelbeat.org/programming/stdio_buffering/">http://www.pixelbeat.org/programming/stdio_buffering/</a>
          <br />
          <a href="https://mywiki.wooledge.org/BashFAQ/009">https://mywiki.wooledge.org/BashFAQ/009</a>
          <br />
          <a href="https://stackoverflow.com/questions/3465619/how-to-make-output-of-any-shell-command-unbuffered"
            >https://stackoverflow.com/questions/3465619/how-to-make-output-of-any-shell-command-unbuffered</a
          >
          <br />
          <a href="https://stackoverflow.com/a/33741419">https://stackoverflow.com/a/33741419</a>

          <pre>
AFAIK, you can't do it without ugly hacks. Writing to a pipe (or reading from it) automatically turns on full buffering and there is nothing you can do about it :-(. "Line buffering" (which is what you want) is only used when reading/writing a terminal. The ugly hacks exactly do this: They connect a program to a pseudo-terminal, so that the other tools in the pipe read/write from that terminal in line buffering mode. The whole problem is described here:          

# from: https://stackoverflow.com/a/3465784
          </pre>
          <script type="editor" data-lang="sh">

            # trick 1 (using 'unbuffer' from 'expect' lib)
            # on mac requires: export HOMEBREW_NO_AUTO_UPDATE=1 && brew install expect
            # on ubuntu requires: apt-get install expect
            # after reading man unbuffer:
              # unbuffer -p may appear to work incorrectly if a process feeding input to unbuffer exits.  Consider:
              #             process1 | unbuffer -p process2 | process3
            # after installing proper dependencies it seems to work on both mac and linux


            printf "

            first line
            \e[32msecond\e[0m line
            \e[33mthird\e[0m line
            \e[35mfourth\e[0m line
            \e[31mfifth\e[0m line
            last line

            " | perl -pe "system 'sleep .3'" | unbuffer -p sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g' | tee color.txt


            # trick 2
            stdbuf -i0 -o0 -e0 command

            #like (using stdbuf makes this example work on linux, but not on mac)

            printf "

            first line
            \e[32msecond\e[0m line
            \e[33mthird\e[0m line
            \e[35mfourth\e[0m line
            \e[31mfifth\e[0m line
            last line

            " | perl -pe "system 'sleep .3'" | stdbuf -i0 -o0 -e0 sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g' | tee color.txt
          </script>

          <h2>xargs</h2>
          <script type="editor" data-lang="sh">

            # https://shapeshed.com/unix-xargs/
            echo -e "one two three\nfour six seven\neight" | xargs -t echo -e xxx
            # echo -e xxx one two three four six seven eight
            # -e xxx one two three four six seven eight
            #    -p  - prompt/user_confirmation mode

            seq 3 | xargs -- echo number
            # number 1 2 3

            seq 3 | xargs -n 1 -- echo number
            # number 1
            # number 2
            # number 3

            # multiple commands
            echo -ne "one two three\nfour six seven\neight" | xargs -I % bash -c "echo \">>%<<\"; echo \":%:\""
            # >>one two three<<
            # :one two three:
            # >>four six seven<<
            # :four six seven:
            # >>eight<<
            # :eight:

            # skip blank lines
            cat <<EOF | xargs -I %% echo ">>%%<<"

            a

            b

            c

            EOF
            # >>a<<
            # >>b<<
            # >>c<<


            # newlines to NUL character
            cat <<EOF | tr '\n' '\0' | xargs -0 -I % -- echo ">>>%<<<"

            a

            b

            c

            EOF
            # >>><<<
            # >>>a<<<
            # >>><<<
            # >>>b<<<
            # >>><<<
            # >>>c<<<
            # >>><<<

            # multiline to one line
            # xargs executes echo by default
            cat <<EOF | xargs

            a

            b

            c

            EOF
            # a b c

            # manually use NUL character
            echo -ne 'one\0two\0three four\nsix seven\0end' | xargs -0 -I % echo ">%<"
            # >one<
            # >two<
            # >three four
            # six seven<
            # >end<

            # read from file instead of stdin
            # WARNING: ONLY LINUX - DOESN'T WORK ON MAC
            xargs -a rss_links.txt

            # different delimiter

            cat <<EOF | xargs -d% -I ^ echo ">>>^<<<"
            qwer
            t%yui
            opasd
            fg%hjh
            klzx
            cvb%
            nm%
            %
            EOF
            # >>>qwer
            # t<<<
            # >>>yui
            # opasd
            # fg<<<
            # >>>hjh
            # klzx
            # cvb<<<
            # >>>
            # nm<<<
            # >>>
            # <<<
            # >>>
            # <<<
          </script>
          <h2>find</h2>
          <a href="https://ss64.com/osx/find.html">https://ss64.com/osx/find.html</a>
          <script type="editor" data-lang="sh">

            tar -zcvf /backup/project.tar.gz --exclude "node_modules" /srv/www/

            # find all node_modules directories excluding nested node_modules (-prune)
            find . -type d -name node_modules -prune -print0 | xargs -0 -I % echo ":%:"

            # find files except matching pattern
            find . -type f -not -name '*gz'

            # limit depth
            find . -type d -maxdepth 1

            # find and tar.gz all png files
            find pages -name "*.png" -type f -print0 | xargs -0 tar -cvzf images.tar.gz

            # remove all found
            find Downloads -name "DomTerm" -type d -print0 | xargs -0 /bin/rm -v -rf "{}"

            mkdir ttt
            cd ttt
            touch a
            touch "b c"
            touch e
            find . -print0 | xargs -0 -I % echo ">>%<<"
            cd ..
            rm -rf ttt
            # >>.<<
            # >>./a<<
            # >>./b c<<
            # >>./e<<

            # excluding search in directory node_modules
            # WARNING: Note that unlike with -prune, the directory to be excluded is still traversed.
            mkdir -p xxxtest
            cd xxxtest
            function k {
                echo ">>${1}"
                DIR="$(dirname "${1}")"
                mkdir -p "${DIR}"
                touch "${1}"
            }
            k "a/b/c.txt"
            k "a/node_modules/c.txt"
            k "a/node_modules/ab/c.txt"
            k "a/node_modules/ab/c/c.txt"
            k "c.txt"
            k "b/c.txt"
            cd ..
            echo -e "\nfind all:"
            find xxxtest
            echo -e "\nfind excluding node_modules:"
            find xxxtest -type f ! -path "*/node_modules/*"
            rm -rf xxxtest

            # more advanced example with -prune
            # https://unix.stackexchange.com/a/350090
            find . -type d -name 'node_modules' -prune -o -type d -name .git -print
                # if this is directory and it's name is node_modules then don't enter it, otherwise, if this is directory and it's name is .git, print it's pathname

                # speed test against huge directory with many project with many big node_modules directories
                find . -type d -name .git ! -path "*/node_modules/*"                        0.89s user 19.89s system 43% cpu 47.779 total
                find . -type d -name .git                                                   0.86s user 19.19s system 40% cpu 49.613 total
                find . -type d -name 'node_modules' -prune -o -type d -name .git -print     0.08s user 1.55s system 46% cpu 3.515 total

                # read more about -prune
                https://stackoverflow.com/a/4210072

            # multiple prune

            find . \( \
                    -type d -name node_modules -prune -o \
                    -type d -name .git -prune -o \
                    -type d -name coverage -prune -o \
                    -type d -name noprettier -prune \
                \) \
                -o \
                -type f -name "*.test.js" -print
          </script>
          <h2>debug</h2>
          <script type="editor" data-lang="sh">

            set -x          # Expand and print each command before executing
            set -e          # Exit script immediately if any command returns a non-zero exit status.
            set -o pipefail # more: https://buildkite.com/docs/pipelines/writing-build-scripts#configuring-bash
              # to turn back on set +o pipefail

            set -u # Exit script immediately if an undefined variable is used (e.g. echo "$UNDEFINED_ENV_VAR").
          </script>
          <h2>remove strip color from stream output</h2>
          <script type="editor" data-lang="sh">

            printf "

            first line
            \e[32msecond\e[0m line
            \e[33mthird\e[0m line
            \e[35mfourth\e[0m line
            \e[31mfifth\e[0m line
            last line

            " | perl -pe "system 'sleep .03'" | sed -r "s/[[:cntrl:]]\[[0-9]{1,3}m//g"

            # look for more: https://stackoverflow.com/q/17998978
          </script>
          <h2>stream - delay stream</h2>
          <script type="editor" data-lang="sh">

            perl -pe "system 'sleep .003'" file.txt
            # or
            cat  file.txt | perl -pe "system 'sleep .003'"
              # from: https://superuser.com/a/526249
          </script>
          <h2>regex</h2>
          <script type="editor" data-lang="sh">

            if [[ ${NAME} =~ ^~{0,1}/.* ]]; then

                echo "match";
            else

                echo "not match";

                exit 1;
            fi

            # https://www.networkworld.com/article/2693361/unix-tip-using-bash-s-regular-expressions.html#:~:text=Since%20version%203%20(circa%202004,easier%20to%20read%20and%20maintain.

            NAME="765876"

            TEST="^[0-9]+$"

            if [[ ${NAME} =~ ${TEST} ]]; then

                echo "match";
            else

                echo "not match";

                exit 1;
            fi
          </script>

          <h2>top</h2>
          <script type="editor" data-lang="sh">

            z,x,E,e,>>,W

            b - refresh
            E - change size units (tob summary bar)
            x - Toggle highlights
            R - normal/reverse sort
            s - update interval 0.05
            W - save settings in ~/.toprc
            k - kill process

            > <  - change sort table
          </script>

          <h2>basics</h2>
          <script type="editor" data-lang="sh">

            function _date {
                date "+%Y-%m-%d"
            }

            function _time {
                date "+%H-%M-%S"
            }
            date "+%Y_%m_%d_%H_%M_%S"

            // stdout stderr
            set -e; _exit 1> /dev/null 2> /dev/null

            echo John have a cat
            echo Cat have a hiv>&2

            ls -la 2>&1


            # on Mac
            bash --version
            GNU bash, version 3.2.57(1)-release (x86_64-apple-darwin20)
            Copyright (C) 2007 Free Software Foundation, Inc.

            arch -arm64 brew install bash
            $ more: https://itnext.io/upgrading-bash-on-macos-7138bd1066ba
            # add to ~/.bashrc
            export PATH="/bin:$PATH"
            # to change back to bash v3



            # -a FILE        True if file exists.
            # -e FILE        True if file exists.
            # -f FILE        True if file exists and is a regular file.
            # -r FILE        True if file is readable by you.
            # -s FILE        True if file exists and is not empty.
            # -w FILE        True if the file is writable by you.

            # Pathname Expansion
            echo *s
            # Documents Pictures Templates Videos

            echo [[:upper:]]*
            # Desktop Documents Music Pictures Public Templates Videos

            echo /usr/*/share
            # /usr/kerberos/share /usr/local/share

            # Arithmetic Expansion
            echo echo $(((5**2) * 3))
            # 75

            # Brace Expansion
            echo Front-{A,B,C}-Back
            # Front-A-Back Front-B-Back Front-C-Back

            echo Number_{1..5}
            # Number_1 Number_2 Number_3 Number_4 Number_5

            echo {Z..A}
            # Z Y X W V U T S R Q P O N M L K J I H G F E D C B A

            echo {2017..2019}-{09..12}
            # mac   : 2017-9 2017-10 2017-11 2017-12 2018-9 2018-10 2018-11 2018-12 2019-9 2019-10 2019-11 2019-12
            # linux : 2017-09 2017-10 2017-11 2017-12 2018-09 2018-10 2018-11 2018-12 2019-09 2019-10 2019-11 2019-12

            echo $(cal)
            # May 2021 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

            echo "$(cal)"
            #       May 2021
            # Mo Tu We Th Fr Sa Su
            #                 1  2
            #  3  4  5  6  7  8  9
            # 10 11 12 13 14 15 16
            # 17 18 19 20 21 22 23
            # 24 25 26 27 28 29 30
            # 31

            # https://www.funtoo.org/Bash_by_Example,_Part_1
            # variable expansion functionality - Chopping strings like a pro

            # IN OTHER WORDS THIS SYNTAX IS FOCUSED ON CHOPPING OFF
            # NOT IN MATCHING AND RETURNING MATCHES BUT CHOPPING THEM OFF AND RETURNING THE REST

            $ MYVAR=foodforthought.jpg
            $ echo ${MYVAR##*fo} # cut to the LAST occurence (CUTS INCLUSIVE) CHOPPING GREEDY - LONGEST POSSIBLE MATCH
            rthought.jpg
            $ echo ${MYVAR#*fo} # cut to the FIRST occurence (CUTS INCLUSIVE) NOT GREEDY - SHORTEST POSSIBLE MATCH
            odforthought.jpg

            # WARNING: BOTH # AND % ARE CASE SENSITIVE !!!!
            # WARNING: BOTH # AND % ARE CASE SENSITIVE !!!!
            # WARNING: BOTH # AND % ARE CASE SENSITIVE !!!!

            $ echo ${MYVAR#*Fo} # cut to the FIRST occurence (CUTS INCLUSIVE) NOT GREEDY - SHORTEST POSSIBLE MATCH
            foodforthought.jpg

            # TIP/MNEMONIC: look on the keyboard the character $ which is bash variable expansion character
            # on the left is # so it is for chopping from the beginning
            # on the right is % so it is for chopping from the end

            $ MYFOO="chickensoup.tar.gz"
            $ echo ${MYFOO%%.*} # cut longest possible from the end - GREEDY
            chickensoup
            $ echo ${MYFOO%.*} # cut shortest possible from the end - NON GREEDY
            chickensoup.tar

            # variable expansion based on a specific character offset and length
            $ EXCLAIM=cowabungazd
            #         12345678901
            $ echo ${EXCLAIM:0:3}
            cow
            $ echo ${EXCLAIM:3:7}
            abungaz
            $ echo ${EXCLAIM:3:17}
            abungazd

            # default value
            ${FRANKY:=Franky}

            # IF ELSE FI
            if [ condition ]
            then
                    action
            elif [ condition2 ]
            then
                    action2
            .
            .
            .
            elif [ condition3 ]
            then

            else
                    actionx
            fi

            # LOOP FOR
            for x in one two three four "six seven"
            do
                echo number $x
            done
            # number one
            # number two
            # number three
            # number four
            # number six seven


            for myfile in /etc/r* /tmp/${MYPATH}/*
            do
                if [ -d "$myfile" ]
                then
                  echo "$myfile (dir)"
                else
                  echo "$myfile"
                fi
            done
            # /etc/racoon (dir)
            # /etc/rc.common
            # /etc/rc.netboot
            # /etc/resolv.conf
            # /etc/rmtab
            # /etc/rpc
            # /etc/rtadvd.conf
            # ../a.sh is a silly file
            # ../a.txt is a silly file
            # ../runtime.tar.gz is a silly file
            # public/coverage is a silly file
            # public/cypress.html is a silly file
            # public/sandbox is a silly file

            cat <<EOF > k.sh
            #!/usr/bin/env bash
            for thing in "\$@"
            do
                echo you typed \${thing}.
            done
            EOF
            chmod a+x k.sh
            ./k.sh a b c "d e" -- "f g" h
            # you typed a.
            # you typed b.
            # you typed c.
            # you typed d e.
            # you typed --.
            # you typed f g.
            # you typed h.


            # call function for each line (foreach): (multiline)
            LIST=$(cat <<EOF
            one
            two three
            four
            six

            seven

            eight
            EOF
            );
            while read -r line ; do echo ">>$line<<" ; done <<< "${LIST}"
            # >>one<<
            # >>two three<<
            # >>four<<
            # >>six<<
            # >><<
            # >>seven<<
            # >><<
            # >>eight<<

            # or

            while read -r line
            do
              echo ">>$line<<"
            done <<< "${LIST}"
          </script>

          <h2>useful links</h2>
          <ul>
            <li><a href="https://buildkite.com/docs/pipelines/writing-build-scripts#configuring-bash">buildkite script guide ("Writing Build Scripts" section in doc)</a></li>
          </ul>

          <h2>RAM disk</h2>
          <script type="editor" data-lang="sh">

            RAMNAME="ramvol"
            MB="8"
            if [ "${RAMNAME}" != "" ] && [ ! -d "/Volumes/${RAMNAME}" ] && [[ ${MB} =~ ^[0-9]+$ ]]; then diskutil erasevolume HFS+ ${RAMNAME} $(hdiutil attach -nomount ram://$((${MB} * 2 * 1024))); else; echo conditions false; fi;

            # from: https://superuser.com/a/1480386
          </script>

          <h2>useful commands</h2>
          <script type="editor" data-lang="sh">

            # ps -p $$ – Display your current shell name reliably.
            # echo "$SHELL" – Print the shell for the current user but not necessarily the shell that is running at the movement.
            # echo $0 – Another reliable and simple method to get the current shell interpreter name on Linux or Unix-like systems.
            # readlink /proc/$$/exe – Another option to get the current shell name reliably on Linux operating systems.
            # cat /etc/shells – List pathnames of valid login shells currently installed
            # grep "^$USER" /etc/passwd – Print the default shell name. The default shell runs when you open a terminal window.

            _0="$(basename "${0}")"

            # current shell name reliably
            _SHELL="$(ps "${$}" | grep "${$} " | grep -v grep | sed -rn "s/.*[-\/]+(bash|z?sh) .*/\1/p")"; # bash || sh || zsh
            case ${_SHELL} in
              zsh)
                _DIR="$( cd "$( dirname "${(%):-%N}" )" && pwd -P )"
                _0="$( basename "${(%):-%N}" )"
                _SCRIPT="${(%):-%N}"
                _BINARY="/bin/zsh"
                _PWD="$(pwd)"
                ;;
              sh)
                _DIR="$( cd "$( dirname "${0}" )" && pwd -P )"
                _0="$( basename "${0}" )"
                _SCRIPT="${0}"
                _BINARY="/bin/sh"
                _PWD="$(pwd)"
                ;;
              *)
                _DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd -P )"
                _0="$( basename "${BASH_SOURCE[0]}" )"
                _SCRIPT="${BASH_SOURCE[0]}"
                _BINARY="/bin/bash"
                _PWD="$(pwd)"
                ;;
            esac

            # test of above
            mkdir -p aaaa_aaaa/bbb/ccc
            cat <<EEE > aaaa_aaaa/bbb/ccc/ddd.sh
            _SHELL="\$(ps "\${\$}" | grep "\${\$} " | grep -v grep | sed -rn "s/.*[-\/]+(bash|z?sh) .*/\1/p")"; # bash || sh || zsh
            echo "====\${_SHELL}:\$(if [ "\${_SHELL}" = "sh" ]; then echo sh; else \${_SHELL} --version; fi | head -n 1)===="
            case \${_SHELL} in
              zsh)
                _DIR="\$( cd "\$( dirname "\${(%):-%N}" )" && pwd -P )"
                _SCRIPT="\${(%):-%N}"
                _BINARY="/bin/zsh"
                _PWD="$(pwd)"
                ;;
              sh)
                _DIR="\$( cd "\$( dirname "\${0}" )" && pwd -P )"
                _SCRIPT="\${0}"
                _BINARY="/bin/sh"
                _PWD="$(pwd)"
                ;;
              *)
                _DIR="\$( cd "\$( dirname "\${BASH_SOURCE[0]}" )" && pwd -P )"
                _SCRIPT="\${BASH_SOURCE[0]}"
                _BINARY="/bin/bash"
                _PWD="$(pwd)"
                ;;
            esac
            echo "_ROOT=\${_DIR}"
            echo "_SCRIPT=\${_SCRIPT}"
            echo "_BINARY=\${_BINARY}"
            echo "_PWD=\${_PWD}"
            EEE
            docker run -it --rm -v "$(pwd):/code" -w "/code" frapsoft/zsh /bin/zsh aaaa_aaaa/bbb/ccc/ddd.sh \
            && docker run -it --rm -v "$(pwd):/code" -w "/code" bash:3.2.57 /usr/local/bin/bash aaaa_aaaa/bbb/ccc/ddd.sh \
            && docker run -it --rm -v "$(pwd):/code" -w "/code" bash:4.4.23 /usr/local/bin/bash aaaa_aaaa/bbb/ccc/ddd.sh \
            && docker run -it --rm --entrypoint="" -v "$(pwd):/code" -w "/code" bash:5.1.8 /usr/local/bin/bash aaaa_aaaa/bbb/ccc/ddd.sh \
            && docker run -it --rm -v "$(pwd):/code" -w "/code" alpine:3.14.2 /bin/sh aaaa_aaaa/bbb/ccc/ddd.sh
            rm -rf aaaa_aaaa


            # detect CURRENT USER default shell - that's different than above
            if [ -n "$ZSH_VERSION" ]; then
               echo -n 'zsh';
            elif [ -n "$BASH_VERSION" ]; then
               echo -n 'bash';
            else
               echo -n 'other';
            fi

            grep 'swap-files' * -rl --exclude-dir={bower_components,node_modules,vendor} --include \*.sh

            arch -arm64 brew install webp
            sudo xattr -dr com.apple.quarantine /path/ff*

            # get ip
            IP=$(ipconfig getifaddr en0)

            ps aux --sort=-%mem | head -n 300
            ps -ef | grep 'garbagecollect' | grep -v grep | awk '{print $2}' | xargs -r kill -9
                # from: https://stackoverflow.com/a/30515012
          </script>

          <h2>kill killall</h2>
          <script type="editor" data-lang="sh">

            #to kill by pattern
            kill $(pgrep -f "/bin/bash stream.sh")
            
            # to test by pattern
            ps -ef | grep "/bin/bash stream.sh"

            # some other stuff
            for KILLPID in `ps ax | grep 'my_pattern' | awk ' { print $1;}'`; do
              kill -9 $KILLPID;
            done

            /bin/bash -c "sleep 5 && kill -- $$" & disown
          </script>
          
          <h2>change user home directory</h2>
          <script type="editor" data-lang="sh">

            kill -9 xxxxxx && usermod -m -d /home/buildkite-agent buildkite-agent
          </script>

          <h2>verifying default shell</h2>
          <script type="editor" data-lang="sh">


             # change default shell
             chsh -s /bin/bash
             chsh -s /bin/zsh

             # to determine currently used shell
            ps -o comm= $$
            echo $SHELL

            # list of available shells
            cat /etc/shells

            zsh --version
            bash --version

            # from: https://www.howtogeek.com/444596/how-to-change-the-default-shell-to-bash-in-macos-catalina/
          </script>
          more about: <a href="https://support.apple.com/en-gb/HT208050">https://support.apple.com/en-gb/HT208050</a>
        </div>
        <div class="cards">
          <h2>export .env</h2>
          <script type="editor" data-lang="sh">

            # https://unix.stackexchange.com/a/79084
            set -a
            source ".env"
            set +a
          </script>
        </div>
        <div class="cards">
          <h2>trap</h2>
          <script type="editor" data-lang="sh">
                        # this example is little messy but I need it just as an example
                          # advanced use ------------------------------------------------- vvv





            function cleanup {

                kill "${PID1}" 1> /dev/null 2> /dev/null || :
            }

            trap cleanup EXIT;

            # run some stuff like
            node server.js &

            PID1="${!}"


            # other examples



            DELETE=("$DOC" "$IGN" "$RUN");

            function cleanup {

              set +x

              for i in "${DELETE[@]}"
              do

                  { yellow "\nremoving '$i'"; } 2>&3

                  unlink "$i" || true
              done
            }

            trap cleanup EXIT;

            # ...
            DELETE+=("$DEPLOYMENT_FILE")
            # ...

            trap - EXIT

              # advanced use ------------------------------------------------- ^^^


                    # ===== multiple traps =============== vvv

            TRAPS=()

            function trigger_traps {

              for i in "${TRAPS[@]}"
              do

                  { yellow "\ntriggering trap: '$i'"; } 2>&3

                  $i || true
              done
            }

            trap trigger_traps EXIT;


            function final { { red "\n\ngeneral error...\n\n"; } 2>&3;}
            TRAPS+=('final')

            # do yours stuff ....

            function final { { green "\n\nall good...\n\n"; } 2>&3;}

            # and then


            function cleanup {

              echo "======================== first cleanup ===========================";

              set +x

              for i in "${DELETE[@]}"
              do

                  { yellow "\nremoving '$i'"; } 2>&3

                  unlink "$i" || true
              done
            }

            TRAPS=("cleanup" "${TRAPS[@]}") # add to beginning of the array
            TRAPS+=('cleanup') # add to the end of array

                    # ===== multiple traps =============== ^^^
          </script>
        </div>

        <div class="cards">
          <h2>zsh colors</h2>

          <script type="editor" data-lang="sh">

            cat <<EOF >> ~/.zshrc
            unset PROMPT;
            if [[ "$EUID" = "0" ]]; then
               PROMPT='%~ %F{#555555}%n%f %(?.%F{#00ff00}√%f.%F{#ff0000}%?%f) '
            else
               PROMPT='%~ %F{#ffff00}%n%f %(?.%F{#00ff00}√%f.%F{#ff0000}%?%f) '
            fi
            EOF
            source ~/.zshrc
          </script>
          <h2>array</h2>
          <a href="https://www.geeksforgeeks.org/array-basics-shell-scripting-set-1/">https://www.geeksforgeeks.org/array-basics-shell-scripting-set-1/</a>

          <script type="editor" data-lang="sh">

            array=(`seq 1 10`)

            declare -A array
            array[first]='First element'
            array[second]='Second element'

            # Print last element using subscript syntax
            echo "${array[-1]}"

            TRAPS=()

            TRAPS=("cleanup" "${TRAPS[@]}") # add to beginning of the array
            TRAPS+=('cleanup') # add to the end of array

            https://stackoverflow.com/a/8574392
            containsElement () {
                local e
                for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
                return 1
            }

            $ array=("something to search for" "a string" "test2000")
            $ containsElement "a string" "${array[@]}"
            $ echo $?
            0
            $ containsElement "blaha" "${array[@]}"
            $ echo $?
            1

            # == learning array ===== VVV https://www.learnshell.org/en/Arrays

            # length
            my_array=(apple banana "Fruit Basket" orange)
            echo ${#my_array[@]}   # length of array (in this case 4)


            my_array=(apple banana "Fruit Basket" orange)
            echo ${my_array[3]}                     # orange zero-indexed then
            my_array[3]="carrot"
            echo ${my_array[3]}                     # carrot
            echo ${my_array[${#my_array[@]}-1]}     # carrot - get last element

            # to string
            ARRAY_VARIABLE=(23 45 34 1 2 3)
            echo ">>${ARRAY_VARIABLE[@]}<<" # >>23 45 34 1 2 3<<
            printf -v STRING_VARIABLE "%s:" "${ARRAY_VARIABLE[@]}"
            echo "++$STRING_VARIABLE++"   # ++23:45:34:1:2:3:++     WARNING: WATCH OUT - LAST ":" CHARACTER


            # show array content
              printf '%s\n' "${branches[@]}"

            # merge two arrays array_merge
              branches=("$main" "${branches[@]}")
          </script>
          <h2>bash colors</h2>

          See also: <a href="https://stackoverflow.com/a/24701349/5560682">link</a> also <a href="https://apple.stackexchange.com/q/60206">link</a>
          <table width="100%">
            <tbody>
              <tr>
                <td>
                  <script type="editor" data-lang="sh">

                    GRAY=$(tput setaf 244)
                    BLACK=$(tput setaf 0)
                    RED=$(tput setaf 1)
                    GREEN=$(tput setaf 2)
                    YELLOW=$(tput setaf 3)
                    BLUE=$(tput setaf 4)
                    MAGENTA=$(tput setaf 5)
                    CYAN=$(tput setaf 6)
                    WHITE=$(tput setaf 7)
                    BOLD=$(tput bold)
                    REVERSE=$(tput rev)
                    RESET=$(tput sgr0)

                    echo "${GRAY}GRAY${RESET}"
                    echo "${BLACK}BLACK${RESET}"
                    echo "${RED}RED${RESET}"
                    echo "${GREEN}GREEN${RESET}"
                    echo "${YELLOW}YELLOW${RESET}"
                    echo "${BLUE}BLUE${RESET}"
                    echo "${MAGENTA}MAGENTA${RESET}"
                    echo "${CYAN}CYAN${RESET}"
                    echo "${WHITE}WHITE${RESET}"
                    echo "${BOLD}BOLD${RESET}"
                    echo "${REVERSE}REVERSE${RESET}"
                  </script>
                </td>
                <td width="150">
                  <img src="https://i.imgur.com/wpJ6go5.png" />
                </td>
              </tr>
            </tbody>
          </table>
          <script type="editor" data-lang="sh">
            # only in bash
            for i in {0..256}; do printf "\e[${i}m\\\\e[${i}m\e[0m ";if [ 256 == ${i} ]; then echo "color"; fi; done

            printf "start\e[94mtest\e[0mend\n"
            printf "start\033[32mtest\e[0mend\n"

            # removing colors from stream

            for i in {0..256}; do printf "\e[${i}m\\\\e[${i}m\e[0m ";if [ 256 == ${i} ]; then echo "color"; fi; done | sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g"

            for i in {0..256}; do printf "\e[${i}m\\\\e[${i}m\e[0m ";if [ 256 == ${i} ]; then echo "color"; fi; done | sed 's/\x1b\[[0-9;]*m//g'
          </script>

          WARNING: MIGHT BE NECESSARY ON MAC TO FIRST INSTALL:

          <script type="editor" data-lang="sh">

            export HOMEBREW_NO_AUTO_UPDATE=1 && brew install coreutils

            dircolors -b
            gdircolors -b
          </script>

          oneliner:
          <script type="editor" data-lang="sh">
            if cat ~/.bashrc 2> /dev/null | grep '#colors mod' > /dev/null; then echo -e "\033[31m -=file .bashrc have been already modified before=-"; else echo -e "\n#colors mod\nexport EDITOR=vi\ncolor_prompt=yes;\nPS1='${debian_chroot:+($debian_chroot)}\[\033[`if [ "$(id -u)" != "0" ]; then echo '00;32'; else echo '1;30'; fi`m\]\u@\h\[\033[00;31m\]:\[\033[01;34m\]\w\[\033[00;33m\]\$ '\neval \"`dircolors -b || gdircolors -b`\"\nexport HISTCONTROL=ignoreboth:erasedups\n" >> ~/.bashrc && source ~/.bashrc && echo -e "\033[32m -= .bashrc has been modified =-"; fi &&        if cat ~/.vimrc 2> /dev/null | grep '" colors mod' > /dev/null; then echo -e "\033[31m -=file .vimrc has been already modified before=-"; else echo -e "\n\" colors mod\n:set number\n:set hlsearch\n:syntax on\n" >> ~/.vimrc && echo -e "\033[32m -= .vimrc has been modified =-"; fi        &&  history -d `history | tail -n 1 | awk '{\$1=\$1;print}' | sed -E 's#^([0-9]*).*#\1#g'` && if [ ! -f ~/.history_backup ] ; then history > ~/.history_backup; fi
          </script>

          full:
          <script type="editor" data-lang="sh">

            if cat ~/.bashrc 2> /dev/null | grep '#colors mod' > /dev/null; then
                echo -e "\033[31m -=file .bashrc have been already modified before=-"
            else
                echo -e "\n#colors mod\nexport EDITOR=vi\ncolor_prompt=yes;\nPS1='${debian_chroot:+($debian_chroot)}\[\033[`if [ "$(id -u)" != "0" ]; then echo '00;32'; else echo '1;30'; fi`m\]\u@\h\[\033[00;31m\]:\[\033[01;34m\]\w\[\033[00;33m\]\$ '\neval \"`dircolors -b || gdircolors -b`\"\nexport HISTCONTROL=ignoreboth:erasedups\n" >> ~/.bashrc
                source ~/.bashrc
                echo -e "\033[32m -= .bashrc has been modified =-";
            fi

            if cat ~/.vimrc 2> /dev/null | grep '" colors mod' > /dev/null; then
                echo -e "\033[31m -=file .vimrc has been already modified before=-"
            else
                echo -e "\n\" colors mod\n:set number\n:set hlsearch\n:syntax on\n" >> ~/.vimrc
                echo -e "\033[32m -= .vimrc has been modified =-";
            fi

            if [ ! -f ~/.history_backup ] ; then
                history > ~/.history_backup
            fi
          </script>
        </div>
        <div class="cards">
          <h2>ping through dns</h2>
          <script type="editor" data-lang="sh">

            while true; do ping -n -q -c1 docker.phaseiilabs.com | grep '('; sleep 2; done
          </script>
        </div>
        <div class="cards">
          <h2>Processing arguments</h2>
          Simple iteration - withouth shift
          <script type="editor" data-lang="sh">


            I="0"
            FOUND_HYPHEN_HYPHEN="0"
            for x in "$@"
            do
              I=$((I + 1))

              if [ "${x}" = "--" ]; then
                FOUND_HYPHEN_HYPHEN="1"
                break;
              fi

              echo "element >${x}< [${I}]"

              if [[ $(( I % 2 )) == 0 ]]; then
                echo even
              else
                echo odd
              fi
              echo ""
            done

            if [ "${FOUND_HYPHEN_HYPHEN}" = "0" ]; then

              cat <<EEE

              -- argument not found

            EEE

              exit 1
            fi
          </script>

          <br />
          <script type="editor" data-lang="sh">


            echo "args: '$@'"

            function quote {
              echo "$1" | sed -E 's/\"/\\"/g'
            }

            _CLEANOLD="0";

            _GEN="gen"

            _DEPLOYMENT_YAML=""

            PARAMS=""
            _EVAL=""
            while (( "$#" )); do
              case "$1" in
                -c|--clean|--clear)
                  _CLEANOLD="1";
                  shift;
                  ;;
                -d|--deployment-yaml)
                  if [ "$2" = "" ]; then                            # PUT THIS CHECKING ALWAYS HERE IF YOU WAITING FOR VALUE
                    echo "$0 error: --deployment-yaml value can't be empty" >&2 # optional
                    exit 1;                                          # optional
                  fi
                  if ! [ -f "$2" ]; then
                    echo "$0 error: --deployment-yaml file '$2' doesn't exist" >&2 # optional
                    exit 1;                                          # optional
                  fi                                           # optional
                  _DEPLOYMENT_YAML="$2";
                  shift 2;
                  ;;
                -g|--gen)
                  if [ "$2" = "" ]; then                            # PUT THIS CHECKING ALWAYS HERE IF YOU WAITING FOR VALUE
                    echo "$0 error: --gen value can't be empty" >&2 # optional
                    exit 1;                                          # optional
                  fi                                                # optional
                  _GEN="$2";
                  shift 2;
                  ;;
                --) # end argument parsing
                  shift;
                  while (( "$#" )); do          # optional
                    if [ "$1" = "&&" ]; then
                      PARAMS="$PARAMS \&\&"
                      _EVAL="$_EVAL &&"
                    else
                      if [ "$PARAMS" = "" ]; then
                        PARAMS="\"$(quote "$1")\""
                        _EVAL="\"$(quote "$1")\""
                      else
                        PARAMS="$PARAMS \"$(quote "$1")\""
                        _EVAL="$_EVAL \"$(quote "$1")\""
            #          PARAMS="$(cat <<EOF
            #$PARAMS
            #- "$1"
            #EOF
            #)"
                      fi
                    fi
                    echo "                PARAMS1>>$PARAMS<<"
                    echo "                _EVAL 2>>$_EVAL<<"
                    shift;                      # optional
                  done                          # optional if you need to pass: /bin/bash $0 -f -c -- -f "multi string arg"
                  break;
                  ;;
                -*|--*=) # unsupported flags
                  echo "$0 error: Unsupported flag $1" >&2
                  exit 1;
                  ;;
                *) # preserve positional arguments
                  if [ "$1" = "&&" ]; then
                      PARAMS="$PARAMS \&\&"
                      _EVAL="$_EVAL &&"
                  else
                    if [ "$PARAMS" = "" ]; then
                        PARAMS="\"$(quote "$1")\""
                        _EVAL="\"$(quote "$1")\""
                    else
                      PARAMS="$PARAMS \"$(quote "$1")\""
                        _EVAL="$_EVAL \"$(quote "$1")\""
            #          PARAMS="$(cat <<EOF
            #$PARAMS
            #- "$1"
            #EOF
            #)"
                    fi
                  fi
                  echo "                PARAMS2>>$PARAMS<<"
                  echo "                _EVAL 1>>$_EVAL<<"
                  shift;
                  ;;
              esac
            done

            trim() {
                local var="$*"
                # remove leading whitespace characters
                var="${var#"${var%%[![:space:]]*}"}"
                # remove trailing whitespace characters
                var="${var%"${var##*[![:space:]]}"}"
                echo -n "$var"
            }

            PARAMS="$(trim "$PARAMS")"
            _EVAL="$(trim "$_EVAL")"

            #if [ "$_DEPLOYMENT_YAML" = "" ]; then
            #
            #    echo -e "\n\n$0 error: parameter _DEPLOYMENT_YAML is not defined - spedify it in --deployment-yaml parameter\n\n";
            #
            #    exit 1;
            #fi

            # set positional arguments in their proper place
            eval set -- "$PARAMS"

            echo "_CLEANOLD: $_CLEANOLD"
            echo "_GEN: $_GEN"

            echo "rest: '$@'"

            echo "count: $#"


            if [[ $# -gt 0 ]]; then

              echo there are arguments

              while (( "$#" )); do
                echo "arg: '$1'"
                shift;
              done
            else

              echo there is no arguments
            fi

            echo "PARAMS>>$PARAMS<<"
            echo "_EVAL>>$_EVAL<<"

            eval "$_EVAL"

            # when you run
            #   /bin/bash arg.sh --gen test -c -- echo "one"     \&\& pwd \&\& echo "two three"
            # the output will be:

            #args: '--gen test -c -- echo one && pwd && echo two three'
            #                PARAMS1>>"echo"<<
            #                _EVAL 2>>"echo"<<
            #                PARAMS1>>"echo" "one"<<
            #                _EVAL 2>>"echo" "one"<<
            #                PARAMS1>>"echo" "one" \&\&<<
            #                _EVAL 2>>"echo" "one" &&<<
            #                PARAMS1>>"echo" "one" \&\& "pwd"<<
            #                _EVAL 2>>"echo" "one" && "pwd"<<
            #                PARAMS1>>"echo" "one" \&\& "pwd" \&\&<<
            #                _EVAL 2>>"echo" "one" && "pwd" &&<<
            #                PARAMS1>>"echo" "one" \&\& "pwd" \&\& "echo"<<
            #                _EVAL 2>>"echo" "one" && "pwd" && "echo"<<
            #                PARAMS1>>"echo" "one" \&\& "pwd" \&\& "echo" "two three"<<
            #                _EVAL 2>>"echo" "one" && "pwd" && "echo" "two three"<<
            #_CLEANOLD: 1
            #_GEN: test
            #rest: 'echo one && pwd && echo two three'
            #count: 7
            #there are arguments
            #arg: 'echo'
            #arg: 'one'
            #arg: '&&'
            #arg: 'pwd'
            #arg: '&&'
            #arg: 'echo'
            #arg: 'two three'
            #PARAMS>>"echo" "one" \&\& "pwd" \&\& "echo" "two three"<<
            #_EVAL>>"echo" "one" && "pwd" && "echo" "two three"<<
            #one
            #/Users/sd/Workspace/projects/monorepo/runtime
            #two three

            # then you can use $_EVAL like this:
            eval $_EVAL
          </script>
          <a href="https://medium.com/@Drew_Stokes/bash-argument-parsing-54f3b81a6a8f">https://medium.com/@Drew_Stokes/bash-argument-parsing-54f3b81a6a8f</a>
        </div>
        <div class="cards">
          <h2>basic auth generator</h2>
          <table>
            <tbody>
              <tr>
                <td width="60">user:</td>
                <td>
                  <input type="text" id="user" />
                </td>
              </tr>
              <tr>
                <td>password:</td>
                <td>
                  <input type="text" id="password" />
                </td>
              </tr>
            </tbody>
          </table>
          <input type="text" style="width: 80%" id="raw" readonly onfocus="this.select()" />
          <input type="text" style="width: 80%" id="header" readonly onfocus="this.select()" />
          <input type="text" style="width: 80%" id="curl" readonly onfocus="this.select()" />
        </div>
        <div class="cards">
          <h2>HEREDOC:</h2>
          <script type="editor" data-lang="sh">

            cat <<EOF | grep def

            abc
            def a
            ghi
            jkl
            def b
            zzz

            EOF

            VAR=$(cat <<END

            ..

            END
            );

            cat <<EOF > .env

            ..

            EOF

            cat <<EOF

            ..

            EOF


            <<\DOC_END

            some documentation at the end of file

            DOC_END


            # QUOTING TEST vvv
            export TTTA="outputvariable"
            export TTTB="outputvalue"

            # one level
            cat <<EEE

            echo "variable: \$TTTA"

            echo "value: $TTTB"

            EEE

            # two levels
            cat <<EOF > ./ttt.sh

            cat <<EEE

            echo "variable: \\\$TTTA"

            echo "value: \$TTTB"

            EEE

            EOF

            /bin/bash ttt.sh
            # QUOTING TEST ^^^

            # preventing variables to expand
            cat << 'EOF' > aaaa.sh
            #!/bin/bash

            echo "Using \"\$*\":"
            for a in "$*"; do
                echo $a;
            done

            echo -e "\nUsing \$*:"
            for a in $*; do
                echo $a;
            done

            echo -e "\nUsing \"\$@\":"
            for a in "$@"; do
                echo $a;
            done

            echo -e "\nUsing \$@:"
            for a in $@; do
                echo $a;
            done
            EOF

            /bin/bash aaaa.sh one two "three four"
            rm -rf aaaa.sh
          </script>

          <h2>linux permissions files</h2>
          <a href="http://linuxcommand.org/lc3_lts0090.php">http://linuxcommand.org/lc3_lts0090.php</a>
          <br />
          <img src="file_permissions.png" style="max-width: 400px" />
          <br />
          <script type="editor" data-lang="sh">

            # create user
            adduser --system --shell '/bin/bash' -m mark

            # add group
            sudo usermod -a -G group-name mark
            sudo usermod -a -G buildkite-agent mark


            ls -l /bin/bash
            # -rwxr-xr-x 1 root root 1113504 Jun  6  2019 /bin/bash
            # The file "/bin/bash" is owned by user "root"
            # The superuser has the right to read, write, and execute this file
            # The file is owned by the group "root"
            # Members of the group "root" can also read and execute this file
            # Everybody else can read and execute this file

            # rwx rwx rwx = 111 111 111
            # rw- rw- rw- = 110 110 110
            # rwx --- --- = 111 000 000

            # and so on...

            # rwx = 111 in binary = 7
            # rw- = 110 in binary = 6
            # r-x = 101 in binary = 5
            # r-- = 100 in binary = 4

            # (Files that are not programs should not be given the execute permission.)

            # 777	(rwxrwxrwx) No restrictions on permissions. Anybody may do anything.
            #                   Generally not a desirable setting.

            # 755	(rwxr-xr-x) The file's owner may read, write, and execute the file. All others may read and execute
            #                   the file. This setting is common for programs that are used by all users.

            # 700	(rwx------) The file's owner may read, write, and execute the file. Nobody else has any rights.
            #                   This setting is useful for programs that only the owner may use and must be kept private
            #                   from others.

            # 666	(rw-rw-rw-) All users may read and write the file.

            # 644	(rw-r--r--) The owner may read and write a file, while all others may only read the file.
            #                   A common setting for data files that everybody may read, but only the owner may change.

            # 600	(rw-------) The owner may read and write a file. All others have no rights. A common setting
            #                   for data files that the owner wants to keep private.

            chown user:group filename
            chgrp group_name filename

            chown batman file
            # chown: changing ownership of 'file': Operation not permitted
            # you have to be root to change ownershipt of the file/dir

            sudo chown batman: file
            # will change user and group to 'batman' (colon)
          </script>
          <br />
          <h2>linux permissions directories</h2>
          <a href="https://youtu.be/Z56Jmr9Z34Q?t=1336">https://youtu.be/Z56Jmr9Z34Q?t=1336</a>
          <img src="permissions.png" style="max-width: 650px" />
          source
          <a href="https://unix.stackexchange.com/a/21263/462348">https://unix.stackexchange.com/a/21263</a>
          <br />
          <img src="table.png" style="max-width: 650px" />
          <script type="editor" data-lang="sh">

            # r - Allows the contents of the directory to be listed if the x attribute is also set.
            # w - Allows files within the directory to be created, deleted, or renamed if the x attribute is also set.
            # x - Allows a directory to be entered (i.e. cd dir).
            #     Being allowed to "enter" a dir and gain possible access to sub-dirs.
          </script>
          <h2>Precedence and parenthesis</h2>
          <a href="https://wiki.bash-hackers.org/commands/classictest#precedence_and_parenthesis">https://wiki.bash-hackers.org/commands/classictest#precedence_and_parenthesis</a>
        </div>
      </div>
    </div>
    <script>
      var user = document.querySelector("#user");
      var password = document.querySelector("#password");
      var raw = document.querySelector("#raw");
      var header = document.querySelector("#header");
      var curl = document.querySelector("#curl");

      user.addEventListener("input", generate);

      password.addEventListener("input", generate);

      function generate() {
        setTimeout(function () {
          var u = user.value;
          var p = password.value;

          if (u && p) {
            console.log(u + ":::" + p);
            var k = btoa(u + ":" + p);
            raw.value = k;
            header.value = "Basic " + k;
            curl.value = 'curl -v --silent -H "authorization: Basic ' + k + '"';
          }
        }, 50);
      }

      (function () {
        var q = location.search.split("#")[0].substring(1);

        if (q.length > 2 && q.indexOf(":") > -1) {
          q = q.split(":");

          console.log("q", q[0], "a", q[1]);

          user.value = q[0];

          password.value = q[1];

          generate();
        } else {
          generate();
        }
      })();
    </script>
    <script src="/js/github.js"></script>
  </body>
</html>
